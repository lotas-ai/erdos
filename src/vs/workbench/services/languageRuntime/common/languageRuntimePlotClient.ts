/*---------------------------------------------------------------------------------------------
 *  Copyright (C) 2025 Lotas Inc. All rights reserved.
 *  Licensed under the AGPL-3.0 License. See LICENSE.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { Disposable } from '../../../../base/common/lifecycle.js';
import { Event, Emitter } from '../../../../base/common/event.js';
import { IErdosPlotClient, IPlotSize, AutomaticPlotSizer } from '../../../contrib/erdosPlots/common/erdosPlotsService.js';
import { IErdosPlotMetadata } from './languageRuntimeMessageTypes.js';

export { IErdosPlotMetadata };

export enum PlotClientState {
	Idle = 'idle',
	Rendering = 'rendering',
	Completed = 'completed',
	Rendered = 'rendered',
	Closed = 'closed',
	Error = 'error'
}

/**
 * An instance of a plot client widget generated by a language runtime via the direct kernel system.
 */
export class PlotClientInstance extends Disposable implements IErdosPlotClient {
	/**
	 * Event that fires when the plot is closed
	 */
	onDidClose: Event<void>;
	private readonly _closeEmitter = this._register(new Emitter<void>());

	/**
	 * Event that fires when the sizing policy is changed
	 */
	onDidChangeSizingPolicy: Event<AutomaticPlotSizer>;
	private readonly _sizingPolicyEmitter = this._register(new Emitter<AutomaticPlotSizer>());

	/**
	 * Event that fires when render completes
	 */
	onDidCompleteRender: Event<any>;
	private readonly _completeRenderEmitter = this._register(new Emitter<any>());

	/**
	 * Event that fires when state changes
	 */
	onDidChangeState: Event<PlotClientState>;
	private readonly _changeStateEmitter = this._register(new Emitter<PlotClientState>());

	/**
	 * Last render output
	 */
	public lastRender?: any;

	/**
	 * Estimated render time in milliseconds
	 */
	public renderEstimateMs?: number;

	/**
	 * Creates a new plot client instance.
	 *
	 * @param _commProxy The proxy that handles comm requests
	 * @param _sizingPolicy The sizing policy for the plot
	 * @param metadata The plot's metadata
	 */
	constructor(
		private readonly _commProxy: { onDidClose: Event<void>; render?: (request: { size?: IPlotSize; pixel_ratio: number }) => Promise<unknown> },
		private _sizingPolicy: AutomaticPlotSizer,
		public readonly metadata: IErdosPlotMetadata
	) {
		super();

		// Connect events
		this.onDidClose = this._closeEmitter.event;
		this.onDidChangeSizingPolicy = this._sizingPolicyEmitter.event;
		this.onDidCompleteRender = this._completeRenderEmitter.event;
		this.onDidChangeState = this._changeStateEmitter.event;

		// Listen for comm close
		this._register(this._commProxy.onDidClose(() => {
			this._closeEmitter.fire();
		}));
	}

	get sizingPolicy() {
		return this._sizingPolicy;
	}

	set sizingPolicy(newSizingPolicy: AutomaticPlotSizer) {
		this._sizingPolicy = newSizingPolicy;
		this._sizingPolicyEmitter.fire(newSizingPolicy);
	}

	/**
	 * Render the plot with the current sizing policy
	 */
	public async renderWithSizingPolicy(size: IPlotSize | undefined, pixel_ratio: number): Promise<any> {
		const optimalSize = size ? this._sizingPolicy.calculateOptimalSize(size) : undefined;
		
		this._changeStateEmitter.fire(PlotClientState.Rendering);
		
		try {
			// If the comm proxy has a render method, use it
			if (this._commProxy?.render) {
				const result = await this._commProxy.render({
					size: optimalSize,
					pixel_ratio
				});
				this.lastRender = result;
				this._changeStateEmitter.fire(PlotClientState.Completed);
				this._completeRenderEmitter.fire(result);
				return result;
			}

			// Otherwise return a resolved promise
			const result = {};
			this.lastRender = result;
			this._changeStateEmitter.fire(PlotClientState.Completed);
			this._completeRenderEmitter.fire(result);
			return result;
		} catch (error) {
			this._changeStateEmitter.fire(PlotClientState.Error);
			throw error;
		}
	}

	/**
	 * Returns the plot's unique ID
	 */
	get id(): string {
		return this.metadata.id;
	}

	override dispose(): void {
		this._closeEmitter.fire();
		super.dispose();
	}
}

